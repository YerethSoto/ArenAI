// Script to convert CSV to TypeScript data file
// Run with: node scripts/parseTopicsCSV.mjs

import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const csvPath = join(__dirname, '..', 'resources', 'temas al 3er ciclo.xlsx - Materias.csv');
const outputPath = join(__dirname, '..', 'src', 'data', 'topicsData.ts');

// Read CSV file
const csvContent = readFileSync(csvPath, 'utf8');
const lines = csvContent.split(/\r?\n/).filter(line => line.trim());

// Skip header
const dataLines = lines.slice(1);

console.log(`Total lines (excluding header): ${dataLines.length}`);

// Parse each line
const topics = [];
let id = 1;

for (const line of dataLines) {
    // Handle CSV with possible commas in quoted fields
    const matches = line.match(/^(\d+),([^,]+),(\d+),(.+)$/);

    if (matches) {
        const subjectId = parseInt(matches[1], 10);
        const name = matches[2].trim();
        let description = matches[4].trim();

        // Remove surrounding quotes if present
        if (description.startsWith('"') && description.endsWith('"')) {
            description = description.slice(1, -1);
        }

        topics.push({
            id: id++,
            name,
            subjectId,
            description,
        });
    } else {
        console.warn(`Could not parse line: ${line.substring(0, 80)}...`);
    }
}

console.log(`Parsed ${topics.length} topics`);

// Count by subject
const subjectCounts = {};
for (const topic of topics) {
    subjectCounts[topic.subjectId] = (subjectCounts[topic.subjectId] || 0) + 1;
}
console.log('Topics by subject:', subjectCounts);

// Generate TypeScript file
const topicsJson = JSON.stringify(topics, null, 4)
    .replace(/"id":/g, 'id:')
    .replace(/"name":/g, 'name:')
    .replace(/"subjectId":/g, 'subjectId:')
    .replace(/"description":/g, 'description:');

const tsContent = `// Topic data from curriculum CSV - ${topics.length} topics
// Source: resources/temas al 3er ciclo.xlsx - Materias.csv
// Generated by: node scripts/parseTopicsCSV.mjs

export interface Topic {
    id: number;
    name: string;
    subjectId: number;
    description: string;
}

export interface TopicWithStats extends Topic {
    score: number;
    studentsCompleted: number;
    totalStudents: number;
    correctAnswers: number;
    incorrectAnswers: number;
    commonMistakes: string[];
    strugglingStudents: { name: string; score: number }[];
    topPerformers: { name: string; score: number }[];
}

// Subject ID mapping from CSV:
// 1 = Matem치ticas
// 2 = Ciencias
// 3 = Espa침ol
// 4 = Estudios Sociales
export const SUBJECTS: Record<number, { name: string; icon: string; color: string }> = {
    1: { name: 'Matem치ticas', icon: '游늻', color: '#3498db' },
    2: { name: 'Ciencias', icon: '游댧', color: '#27ae60' },
    3: { name: 'Espa침ol', icon: '游닄', color: '#e67e22' },
    4: { name: 'Estudios Sociales', icon: '游깵', color: '#9b59b6' },
};

// All ${topics.length} topics from the curriculum CSV
export const ALL_TOPICS: Topic[] = ${topicsJson};

// Export complete topics (same as ALL_TOPICS, for compatibility)
export const COMPLETE_TOPICS: Topic[] = ALL_TOPICS;

// Mock student names
const STUDENT_NAMES = [
    'Ana Garc칤a', 'Carlos M칠ndez', 'Mar칤a L칩pez', 'Diego S치nchez',
    'Sof칤a Torres', 'Luis Rodr칤guez', 'Elena Mart칤nez', 'Pedro G칩mez',
];

// Seeded random for consistent mock data
function seededRandom(seed: number): number {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

// Generate mock stats for a topic
export function generateMockStats(topic: Topic, totalStudents: number = 28): TopicWithStats {
    const seed = topic.id * 31 + topic.subjectId * 17;
    const score = Math.floor(35 + seededRandom(seed) * 60);
    const completed = Math.floor(totalStudents * (0.65 + seededRandom(seed + 1) * 0.35));
    const totalAnswers = completed * 5;

    const mistakesBySubject: Record<number, string[]> = {
        1: ['Error en operaciones', 'Confusi칩n de signos'],
        2: ['Confusi칩n de conceptos', 'Vocabulario t칠cnico'],
        3: ['Ortograf칤a', 'Uso de tildes'],
        4: ['Fechas incorrectas', 'Confusi칩n de eventos'],
    };

    return {
        ...topic,
        score,
        studentsCompleted: completed,
        totalStudents,
        correctAnswers: Math.floor(totalAnswers * score / 100),
        incorrectAnswers: Math.floor(totalAnswers * (1 - score / 100)),
        commonMistakes: mistakesBySubject[topic.subjectId] || [],
        strugglingStudents: STUDENT_NAMES.slice(6, 8).map((name, i) => ({
            name, score: Math.max(15, score - 25 + i * 5),
        })),
        topPerformers: STUDENT_NAMES.slice(0, 2).map((name, i) => ({
            name, score: Math.min(100, score + 15 + i * 5),
        })),
    };
}

// Get all topics with stats
export function getTopicsWithStats(totalStudents: number = 28): TopicWithStats[] {
    return ALL_TOPICS.map(t => generateMockStats(t, totalStudents));
}

// Get topics by subject
export function getTopicsBySubject(subjectId: number | null): Topic[] {
    if (subjectId === null) return ALL_TOPICS;
    return ALL_TOPICS.filter(t => t.subjectId === subjectId);
}

// Subject stats interface
export interface SubjectStats {
    subjectId: number;
    name: string;
    icon: string;
    color: string;
    topicCount: number;
    averageScore: number;
    lowCount: number;
    mediumCount: number;
    highCount: number;
    topTopics: TopicWithStats[];
    weakTopics: TopicWithStats[];
}

export function getSubjectStats(totalStudents: number = 28): SubjectStats[] {
    const topicsWithStats = getTopicsWithStats(totalStudents);

    return Object.entries(SUBJECTS).map(([id, subject]) => {
        const subjectTopics = topicsWithStats.filter(t => t.subjectId === parseInt(id));
        const avgScore = subjectTopics.length > 0
            ? Math.round(subjectTopics.reduce((sum, t) => sum + t.score, 0) / subjectTopics.length)
            : 0;
        const sorted = [...subjectTopics].sort((a, b) => b.score - a.score);

        return {
            subjectId: parseInt(id),
            ...subject,
            topicCount: subjectTopics.length,
            averageScore: avgScore,
            lowCount: subjectTopics.filter(t => t.score < 60).length,
            mediumCount: subjectTopics.filter(t => t.score >= 60 && t.score < 80).length,
            highCount: subjectTopics.filter(t => t.score >= 80).length,
            topTopics: sorted.slice(0, 5),
            weakTopics: sorted.slice(-5).reverse(),
        };
    });
}

// Class overview
export interface ClassOverview {
    totalStudents: number;
    totalTopics: number;
    classAverage: number;
    completionRate: number;
    lowTopics: number;
    mediumTopics: number;
    highTopics: number;
    bySubject: { id: number; name: string; avg: number; count: number }[];
}

export function getClassOverview(totalStudents: number = 28): ClassOverview {
    const topicsWithStats = getTopicsWithStats(totalStudents);
    const avg = Math.round(topicsWithStats.reduce((s, t) => s + t.score, 0) / topicsWithStats.length);
    const completion = Math.round(
        topicsWithStats.reduce((s, t) => s + t.studentsCompleted / t.totalStudents, 0) / topicsWithStats.length * 100
    );

    return {
        totalStudents,
        totalTopics: topicsWithStats.length,
        classAverage: avg,
        completionRate: completion,
        lowTopics: topicsWithStats.filter(t => t.score < 60).length,
        mediumTopics: topicsWithStats.filter(t => t.score >= 60 && t.score < 80).length,
        highTopics: topicsWithStats.filter(t => t.score >= 80).length,
        bySubject: Object.entries(SUBJECTS).map(([id, s]) => {
            const topics = topicsWithStats.filter(t => t.subjectId === parseInt(id));
            return {
                id: parseInt(id),
                name: s.name,
                avg: topics.length ? Math.round(topics.reduce((sum, t) => sum + t.score, 0) / topics.length) : 0,
                count: topics.length,
            };
        }),
    };
}
`;

writeFileSync(outputPath, tsContent, 'utf8');
console.log(`\\nGenerated: ${outputPath}`);
console.log('Done!');
